[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pyani-plus Design Documentation",
    "section": "",
    "text": "Preface to pyani-plus design documentation\nWelcome to the design documentation for pyani-plus.",
    "crumbs": [
      "Preface to `pyani-plus` design documentation"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "pyani-plus Design Documentation",
    "section": "Overview",
    "text": "Overview\nThis set of webpages is a place for the pyani-plus development team to make notes about and otherwise record aspects of the design of pyani-plus. This may include but is not restricted to:\n\nplanned developments for pyani-plus\nexpected behaviour for pyani-plus\nstyle guides and other team documentation\nnotes on genome comparison and other algorithms\nnotes on the use of third-party tools relevant to pyani-plus\nexpected and actual behaviour of third-party tools relevant to pyani-plus",
    "crumbs": [
      "Preface to `pyani-plus` design documentation"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This book comprises a set of design documents for the pyani-plus team. In this documentation we record a range of aspects of development and design relevant to pyani-plus, including:\n\nplanned developments for pyani-plus\nexpected behaviour for pyani-plus\nstyle guides and other team documentation\nnotes on genome comparison and other algorithms\nnotes on the use of third-party tools relevant to pyani-plus\nexpected and actual behaviour of third-party tools relevant to pyani-plus",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "part-dev.html",
    "href": "part-dev.html",
    "title": "Development",
    "section": "",
    "text": "This section of the documentation describes style and good practices choices for the repository. Please consult this if you are a project developer, or would like to make a contribution.",
    "crumbs": [
      "Development"
    ]
  },
  {
    "objectID": "contributing.html",
    "href": "contributing.html",
    "title": "2  Contributing",
    "section": "",
    "text": "2.1 Obtaining the current documentation\nTo get a local copy of the documentation on your own machine, clone the repository to your own machine. For example, at the command-line you might issue:\nwhich will create a new directory called design-documentation in the current location.",
    "crumbs": [
      "Development",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contributing</span>"
    ]
  },
  {
    "objectID": "contributing.html#obtaining-the-current-documentation",
    "href": "contributing.html#obtaining-the-current-documentation",
    "title": "2  Contributing",
    "section": "",
    "text": "git clone git@github.com:pyani-plus/design-documentation.git\n\n\n2.1.1 Project content layout\nAs is standard for Quarto projects, the top level - the same one with the Rproj file - contains a set of .qmd files - one for each page of the documentation. The ordering of these pages is determined by the chapters section in the _quarto.yml configuration file, not by filename.\n\n\n\n\n\n\nCaution\n\n\n\nPlease keep all document pages in the top level of this repository.\n\n\nThe assets subdirectory is used to hold additional, non-.qmd files, such as images, each datatype contained within their own nested subfolder.\ndesign-documentation\n  |\n  assets\n    |\n    data\n    |\n    images\n    | \n    papers\n\ndata - contains datafiles (e.g. example third-party program output).\nimages - contains image files\npapers - contains references and other material it’s useful to have accompany this documentation\n\n\n\n\n\n\n\nCaution\n\n\n\nPlease organise all asset files under the assets subdirectory as outlined above\n\n\n\n\n2.1.2 Project styling and configuration\nStyling and configuration is controlled mainly by two YAML files: _quarto.yml and _variables.yml.\n\n_quarto.yml - describes headers, footers, titles, page ordering, etc.\n_variables.yml - describes variables that can be reused throughout the document\n\n\n\n\n\n\n\nCaution\n\n\n\nPlease use the _variables.yml file where appropriate to define variables that may be reused at many points in the document, such as contact emails, paths repository features, and so on.",
    "crumbs": [
      "Development",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contributing</span>"
    ]
  },
  {
    "objectID": "contributing.html#editing-the-documentation",
    "href": "contributing.html#editing-the-documentation",
    "title": "2  Contributing",
    "section": "2.2 Editing the documentation",
    "text": "2.2 Editing the documentation\n\n\n\n\n\n\nImportant\n\n\n\nIf you are working in the pyani-plus/ organisation the first action for editing or creating a new section should be to create a new branch with, e.g. git checkout -b issue_1.\nIf you are not working in the pyani-plus organisation you should be working in your own fork of the repository.\n\n\n\n\n\n\n\n\nCaution\n\n\n\nBefore editing the documentation, please be sure that you are not working in the main branch. The main branch is locked for push actions, and attempts to push direct to main will fail. Please see the section on submitting changes below.\n\n\nThis documentation is written in Quarto and can, technically, be edited in any standard code editor (e.g. VS Code, Emacs or Vim). However, it may be most convenient to edit the project using RStudio Desktop, which has native Quarto and git/GitHub integration.\nThe repository is an RStudio project, which is defined in the design-docs.Rproj file (.Rproj files are the definition files for these projects). To open the project, either open the .Rproj file from within RStudio Desktop, or double-click the file in your file manager window. The project should open in RStudio Desktop, if it is installed.",
    "crumbs": [
      "Development",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contributing</span>"
    ]
  },
  {
    "objectID": "contributing.html#making-suggestions",
    "href": "contributing.html#making-suggestions",
    "title": "2  Contributing",
    "section": "2.3 Making suggestions",
    "text": "2.3 Making suggestions\nIf you have spotted an error, or would like to suggest a change to the documentation, and cannot or do not want to make changes to the documentation yourself - or cannot make those changes immediately - please create an issue on the repository.\n\nCreate an issue for this documentation",
    "crumbs": [
      "Development",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contributing</span>"
    ]
  },
  {
    "objectID": "contributing.html#example-workflow",
    "href": "contributing.html#example-workflow",
    "title": "2  Contributing",
    "section": "2.4 Example Workflow",
    "text": "2.4 Example Workflow\nThis example workflow describes the actions required for a developer in the pyani-plus-dev team.\n\n2.4.1 Clone the repository to your local machine\ngit clone git@github.com:pyani-plus/design-documentation.git\n\n\n2.4.2 Create a new branch\nUse a short string that is informative for your changes, e.g.\ngit checkout -b issue_1\n\n\n2.4.3 Make your edits\nUpdate the documentation as you need to, checking that the documentation still builds by rendering it locally on your machine.\n\n\n2.4.4 Rebase your local changes against main\nIn case changes have happened in the main branch, you should rebase your branch against the current state of main.\ngit fetch\ngit checkout my_branch\ngit rebase origin/main\nThis replays your local changes on top of the current state of main on GitHub. Once this is done, please rerender to check that the documentation still builds.\n\n\n2.4.5 Push the changes\nPush the changes you made to the repository, e.g.\ngit push origin\n\n\n2.4.6 Make a pull request\nMake a pull request against main from your new branch, at GitHub.\n\n\n2.4.7 Participate in review\nMaking the pull request will prompt a code review. The changes might be accepted immediately without modification, after a delay, be modified, or require discussion in the pull request chat.",
    "crumbs": [
      "Development",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Contributing</span>"
    ]
  },
  {
    "objectID": "recording-contributions.html",
    "href": "recording-contributions.html",
    "title": "3  Recording Contributions",
    "section": "",
    "text": "3.1 Using All Contributors\nThe All Contributors bot monitors GitHub issues and pull requests for specially constructed phrases containing the command @all-contributors add, with text that describes the nature of the contribution. For example, creating a new GitHub issue with the text:\nshould prompt the @all-contributors bot to modify files in the repository and record the requested information.\nPlease see this link for more information about command structure, and this link for a description of contribution types and the corresponding emojis.",
    "crumbs": [
      "Development",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Recording Contributions</span>"
    ]
  },
  {
    "objectID": "recording-contributions.html#using-all-contributors",
    "href": "recording-contributions.html#using-all-contributors",
    "title": "3  Recording Contributions",
    "section": "",
    "text": "@all-contributors please add @widdowquinn for code and infrastructure\n\n\n\n3.1.1 Currently-monitored repositories\n\ndesign-documentation",
    "crumbs": [
      "Development",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Recording Contributions</span>"
    ]
  },
  {
    "objectID": "recording-contributions.html#which-files-are-modified-or-related-to-all-contributors",
    "href": "recording-contributions.html#which-files-are-modified-or-related-to-all-contributors",
    "title": "3  Recording Contributions",
    "section": "3.2 Which files are modified, or related to @all-contributors?",
    "text": "3.2 Which files are modified, or related to @all-contributors?\nContributions are recorded in two files: README.md and CONTRIBUTORS.md. These are automagically updated by the bot, and there are protected areas, fenced by the following directives:\n&lt;!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section --&gt;\n&lt;!-- prettier-ignore-start --&gt;\n&lt;!-- markdownlint-disable --&gt;\n\n&lt;!-- markdownlint-restore --&gt;\n&lt;!-- prettier-ignore-end --&gt;\n\n&lt;!-- ALL-CONTRIBUTORS-LIST:END --&gt;\n\nand\n&lt;!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section --&gt;\n\n&lt;!-- ALL-CONTRIBUTORS-BADGE:END --&gt;\n\nThe format of how @all-contributors populates these sections is controlled by the .all-contributorsrc file.\n\n\n\n\n\n\nTip\n\n\n\nWhen attempting to set up the bot, errors of type “trouble processing your request” were received. The issue was fixed by deleting the .all-contributorsrc file, as per this issue.",
    "crumbs": [
      "Development",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Recording Contributions</span>"
    ]
  },
  {
    "objectID": "part-jobs.html",
    "href": "part-jobs.html",
    "title": "Job Distribution",
    "section": "",
    "text": "This section of the documentation contains material concerning third-party job distribution, e.g. using SGE/SLURM/Snakemake/asyncio.",
    "crumbs": [
      "Job Distribution"
    ]
  },
  {
    "objectID": "sqlite.html",
    "href": "sqlite.html",
    "title": "4  SQLite3",
    "section": "",
    "text": "4.1 Overview\nWe have used sqlite3 for persistent storage of analysis results in previous versions of pyani, and we will continue to do so.\nThe main issue we have faced is performance. In previous versions of pyani there was a single operation to populate the results database serially with output from each analysis. This was a detriment to performance, as it required\nNeeding to wait for all comparisons to complete, especially for large analyses, sometimes left “dead time” on the server where most cores were not conducting comparisons, but no database population was taking place. This time could have been used more efficiently.\nThe need to populate the database serially did not take advantage of sqlite’s ability to manage concurrent connections.",
    "crumbs": [
      "Job Distribution",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SQLite3</span>"
    ]
  },
  {
    "objectID": "sqlite.html#overview",
    "href": "sqlite.html#overview",
    "title": "4  SQLite3",
    "section": "",
    "text": "all comparisons to complete before the database was populated\neach comparison to be added in turn\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe behaviour we would like is that, immediately after each analysis is concluded, the result is added to the sqlite3 database, removing the need to wait for all analyses to conclude.",
    "crumbs": [
      "Job Distribution",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SQLite3</span>"
    ]
  },
  {
    "objectID": "sqlite.html#proposal",
    "href": "sqlite.html#proposal",
    "title": "4  SQLite3",
    "section": "4.2 Proposal",
    "text": "4.2 Proposal\nWhen we run a pairwise comparison, we carry out the comparison using a wrapper script that conducts the comparison, and then populates the database, e.g. \n#!/usr/bin/env bash\n\nrun_comparison sequence_A sequence_B -o output.tab  # run pairwise comparison\npopulate_db dbpath output.tab  # populate sqlite database with data from the output file",
    "crumbs": [
      "Job Distribution",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SQLite3</span>"
    ]
  },
  {
    "objectID": "sqlite.html#test-implementation",
    "href": "sqlite.html#test-implementation",
    "title": "4  SQLite3",
    "section": "4.3 Test implementation",
    "text": "4.3 Test implementation\nA test implementation is available under examples/sqlite/concurrency.",
    "crumbs": [
      "Job Distribution",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>SQLite3</span>"
    ]
  },
  {
    "objectID": "part-anim.html",
    "href": "part-anim.html",
    "title": "ANIm",
    "section": "",
    "text": "This section of the documentation includes material specifically relevant to calculation and execution of the ANIm method.",
    "crumbs": [
      "ANIm"
    ]
  },
  {
    "objectID": "anim-method.html",
    "href": "anim-method.html",
    "title": "5  The ANIm Methodology",
    "section": "",
    "text": "5.1 Publications describing ANIm",
    "crumbs": [
      "ANIm",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The ANIm Methodology</span>"
    ]
  },
  {
    "objectID": "anim-method.html#publications-describing-anim",
    "href": "anim-method.html#publications-describing-anim",
    "title": "5  The ANIm Methodology",
    "section": "",
    "text": "Richter and Rosselló-Móra (2009): The initial announcement of the ANIm method\n\n\n\n\n\nRichter, Michael, and Ramon Rosselló-Móra. 2009. “Shifting the Genomic Gold Standard for the Prokaryotic Species Definition.” Proc. Natl. Acad. Sci. U. S. A. 106 (45): 19126–31.",
    "crumbs": [
      "ANIm",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>The ANIm Methodology</span>"
    ]
  },
  {
    "objectID": "deltafiles.html",
    "href": "deltafiles.html",
    "title": "6  .delta files",
    "section": "",
    "text": "6.1 Definition\n.delta file format is defined in the MUMmer3 manual (see below).",
    "crumbs": [
      "ANIm",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>`.delta` files</span>"
    ]
  },
  {
    "objectID": "deltafiles.html#definition",
    "href": "deltafiles.html#definition",
    "title": "6  .delta files",
    "section": "",
    "text": "The .delta file format (from MUMmer 3 documentation)\n\n\n\n\n\nThe “delta” file is an encoded representation of the all-vs-all alignment between the input sequences to either the NUCmer or PROmer pipeline. It is the primary output of these alignment scripts and there are various utilities described in section 5.4. that are designed to take the delta file as input, and output some human-readable information to the user. Also, the delta-filter utility is designed to manipulate these files and select desired alignments. The primary function of the delta file is to catalog the coordinates of each alignment and note the distance between insertions and deletions contained in these alignments. By only storing the location of each indel as an offset, disk space is efficiently utilized, and a potentially enormous alignment can be stored in a relatively small space. The first line lists the two original input files separated by a space, while the second line specifies the alignment data type, either “NUCMER” or “PROMER”. Every grouping of alignments have a unique header specifying the two aligning sequences. Only sequences with shared alignments will have a header; therefore, there can be no empty headers (i.e. those that have no alignments following them). An example header might look like\n&gt;tagA1 tagB1 500 20000000\nFollowing this sequence header is the alignment data. Each alignment following also has a header that describes the coordinates of the alignment and some error information. These coordinates are inclusive and reference the forward strand of the DNA sequence, regardless of the alignment type (DNA or amino acid). Thus, if the start coordinate is greater than the end coordinate, the alignment is on the reverse strand. The four coordinates are the start and end in the reference and the start and end in the query respectively. The three digits following the location coordinates are the number of errors (non-identities + indels), similarity errors (non-positive match scores), and stop codons (does not apply to DNA alignments, will be “0”). An example header might look like:\n2631 3401 2464 3234 15 15 2\nNotice that the start coordinate points to the first base in the first codon, and the end coordinate points to the last base in the last codon. Therefore making (end - start + 1) % 3 = 0. This makes determining the frame of the amino acid alignment a simple matter of determining the reading frame of the start coordinate for the reference and query. Obviously, these calculations are not necessary when dealing with vanilla DNA alignments.\nEach of these alignment headers is followed by a string of signed digits, one per line, with the final line before the next header equaling 0 (zero). Each digit represents the distance to the next insertion in the reference (positive int) or deletion in the reference (negative int), as measured in DNA bases OR amino acids depending on the alignment data type. For example, with the PROMER data type, the delta sequence (1, -3, 4, 0) would represent an insertion at positions 1 and 7 in the translated reference sequence and an insertion at position 3 in the translated query sequence. Or with letters:\nA = ABCDACBDCAC$\nB = BCCDACDCAC$\nDelta = (1, -3, 4, 0)\nA = ABC.DACBDCAC$\nB = .BCCDAC.DCAC$\nUsing this delta information, it is possible to re-generate the alignments calculated by nucmer or promer as is done in the show-coords program. This allows various utilities to be crafted to process and analyze the alignment data using a universal format. This also means the delta only needs to be created once, yet it can be analyzed numerous times without ever having to rerun the costly alignment algorithm. Below is an example of what a delta file might look like:\n/home/username/reference.fasta /home/username/query.fasta\nPROMER\n&gt;tagA1 tagB1 3000000 2000000\n1667803 1667078 1641506 1640769 14 7 2\n-145\n-3\n-1\n-40\n0\n1667804 1667079 1641507 1640770 10 5 3\n-146\n-1\n-1\n-34\n0\n&gt;tagA2 tagB4 4000 3000\n2631 3401 2464 3234 4 0 0\n0\n2608 3402 2456 3235 10 5 0\n7\n1\n1\n1\n1\n0\n(output continues ...)",
    "crumbs": [
      "ANIm",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>`.delta` files</span>"
    ]
  },
  {
    "objectID": "deltafiles.html#sec-interpreting-alignments",
    "href": "deltafiles.html#sec-interpreting-alignments",
    "title": "6  .delta files",
    "section": "6.2 Interpreting alignments",
    "text": "6.2 Interpreting alignments\nIn the MUMmer documentation (see callout box above), an example alignment is presented:\nA = ATCGACTGCAC$\nB = TCCGACGCAC$\nDelta = (1, -3, 4, 0)\nA = ATC.GACTGCAC$\nB = .TCCGAC.GCAC$\nHere, A is the query and B is the reference. The corresponding .delta file would look like this:\nA.fna B.fna\nNUCMER\n&gt; A B 11 10 \n1 11 1 10 3 3 0\n1\n-3\n4\n0\nWe can obtain, or calculate, a number of values for this alignment.\n\nreference sequence length: 11\nquery sequence length: 10\nreference alignment start base: 1\nreference alignment end base: 11\n\nreference alignment length = 11 - 1 + 1 = 11\n\nquery alignment start base: 1\nquery alignment end base: 10\n\nquery alignment length = 10 - 1 + 1 = 10\n\nerrors: 3\nsimilarity errors: 3\ninsertions in the reference: 1 (one negative value)\ninsertions in the query: 2 (two positive values)\ntotal indel count: 3 (the count of nonzero numbers after the alignment header)\n\nBut how long is the alignment? There are 12 positions in the alignment: 11 query bases plus a gap (insertion in the reference); or 10 reference bases plus two gaps (insertions in the query).\n\n\n\n\n\n\nImportant\n\n\n\nThe length of the alignment is 12, and it is longer than either of the aligned sequences.\n\n\n\ntotal alignment length: 12\n\nreference length plus insertions in the reference: 11 + 1\nquery length plus insertions in the query: 10 + 2\n\n\nFrom this alignment we can calculate the coverage for the query and the reference sequence, and the percentage identity for the match.\n\n6.2.1 Percentage identity\nThe percentage identity of the match is the fraction of aligned, matching bases in the alignment. Inspection of the alignment above tells us that this is 9/12 = 0.75. This value can also be calculated from the total alignment length and the number of similarity errors (mismatches plus gaps).\n\n\n\n\n\n\nPercentage identity calculation\n\n\n\n\\[\\textrm{percentage identity} = 1 - \\frac{\\textrm{similarity errors}}{\\textrm{total alignment length}}\\]\n\n\n\n\n6.2.2 Coverage\nCoverage is calculated separately for the two aligned sequences. Query coverage is the proportion of bases in the query that are aligned to a base in the reference sequence. Reference coverage is the proportion of bases in the reference that are aligned to a base in the query sequence.\nThe number of aligned bases is the same for both sequences. In the alignment above it is 12 - 3 = 9, the total alignment length minus the total indel count. But the lengths of the sequences differ, as do the number of so the coverages are:\n\n\n\n\n\n\nPercentage identity calculation\n\n\n\n\\[\\textrm{query coverage} = 1 - \\frac{\\textrm{total alignment length - total indel count}}{\\textrm{query length}}\\] \\[\\textrm{reference coverage} = 1 - \\frac{\\textrm{total alignment length - total indel count}}{\\textrm{reference length}}\\]\n\n\nWhich here gives us a reference coverage of 9/11 ≈ 0.82, and a query coverage of 9/12 = 0.75.",
    "crumbs": [
      "ANIm",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>`.delta` files</span>"
    ]
  },
  {
    "objectID": "deltafiles.html#overlapping-alignments",
    "href": "deltafiles.html#overlapping-alignments",
    "title": "6  .delta files",
    "section": "6.3 Overlapping alignments",
    "text": "6.3 Overlapping alignments\nThe approach in Section 6.2 works for simple cases, but in real genome comparisons we may end up with repeat regions, and overlapping alignments. There are many ways to handle and calculate values like sequence identity and coverage from this kind of data, and we need to make an algorithmic choice.\n\n\n\n\n\n\nImportant\n\n\n\nThis problem arose in an issue raised for an earlier pyani version. Here, Donovan Parks noted that pyani was returning a genome coverage value of greater than unity. This should not have happened, and the methodology described here is intended to avoid a recurrence.\n\n\n\n6.3.1 A .delta file with overlaps\nThe callout box below contains a MUMMer output .delta file, which results from a comparison between two virus sequences. There is a repeat in the genome which results in overlapping alignments, and previously gave a genome coverage of greater than unity.\n\n\n\n\n\n\n.delta file with overlapping alignments\n\n\n\n\n\ndonovan_test/AF_bug_v2/MGV-GENOME-0357962.fna donovan_test/AF_bug_v2/MGV-GENOME-0358017.fna\nNUCMER\n&gt;MGV_MGV-GENOME-0357962 MGV_MGV-GENOME-0358017 87285 87353\n1 24024 63330 87353 5 5 0\n0\n23884 24176 1 293 0 0 0\n0\n24107 87285 176 63368 51 51 0\n-121\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-10416\n-1\n0\n\n\n\nThere are three alignments, overlapping on the query between bases 23884 to 24024, and bases 24107 to 24176.\nThis extract of the dnadiff.pl output report summarises the issue:\ndonovan_test/AF_bug_v2/MGV-GENOME-0357962.fna donovan_test/AF_bug_v2/MGV-GENOME-0358017.fna\nNUCMER\n\n                               [REF]                [QRY]\n[Sequences]\nTotalSeqs                          1                    1\nAlignedSeqs               1(100.00%)           1(100.00%)\nUnalignedSeqs               0(0.00%)             0(0.00%)\n\n[Bases]\nTotalBases                     87285                87353\nAlignedBases          87285(100.00%)       87353(100.00%)\nUnalignedBases              0(0.00%)             0(0.00%)\n\n[Alignments]\n1-to-1                             3                    3\nTotalLength                    87496                87510\nAvgLength                   29165.33             29170.00\nAvgIdentity                    99.94                99.94\n\nM-to-M                             3                    3\nTotalLength                    87496                87510\nAvgLength                   29165.33             29170.00\nAvgIdentity                    99.94                99.94\nIt notes that the query sequence length is 87353 bases, and the reference sequence length is 87275. However, the alignment length runs for 87510 bases on the query, and 87496 bases on the reference sequence. The alignment is longer than either sequence participating in the alignment.\nThe dnadiff.pl output reports sequence identity (AvgIdentity) and sequence coverage (AlignedBases, parenthetical) scores. Using the criteria and definitions we outlined above, we can calculate our own values from the .delta file:\n\nquery sequence length: 87353\nreference sequence length: 87285\nquery alignment length: (24024 - 1 + 1) + (24176 - 23884 + 1) + (87285 - 24107 + 1) = 87496\nreference alignment length: (87353 - 63330 + 1) + (293 - 1 + 1) + (63368 - 176 + 1) = 87510\nerrors: 51\nsimilarity errors: 51\ninsertions in the reference: 14 (14 negative values)\ninsertions in the query: 0 (no positive values)\ntotal indel count: 14 (the total count of nonzero numbers after the alignment header)\ntotal alignment length: ?????\n\nreference length plus insertions in the reference: 87285 + 14 = 87299\nquery length plus insertions in the query: 87353 + 0 = 87353\n\n\nThis is in conflict with the dnadiff.pl output - the total alignment length doesn’t seem to match. So where does dnadiff.pl get its AlignedBases count from?\n\n\n6.3.2 dnadiff.pl’s AlignedBases count\nMUMmer’s dnadiff.pl script effectively implements a workflow of several MUMmer tools:\n$NUCMER --maxmatch -p $OPT_Prefix $OPT_RefFile $OPT_QryFile\n$DELTA_FILTER -1 $OPT_DeltaFile &gt; $OPT_DeltaFile1\n$DELTA_FILTER -m $OPT_DeltaFile &gt; $OPT_DeltaFileM\n$SHOW_COORDS -rclTH $OPT_DeltaFile1 &gt; $OPT_CoordsFile1\n$SHOW_COORDS -rclTH $OPT_DeltaFileM &gt; $OPT_CoordsFileM\n$SHOW_SNPS -rlTHC $OPT_DeltaFile1 &gt; $OPT_SnpsFile\n$SHOW_DIFF -rH $OPT_DeltaFileM &gt; $OPT_DiffRFile\n$SHOW_DIFF -qH $OPT_DeltaFileM &gt; $OPT_DiffQFile\ndnadiff.pl prefers the many-to-many (M indication) output for calculating most of its main statistics in the report. Ultimately, the values in AlignedBases are calculated and printed using the code below:\n    printf $fho \"%-15s %20s %20s\\n\",\n    \"AlignedBases\",\n    ( sprintf \"%10d(%.4f%%)\",\n      $rnABases, ($rnBases ? $rnABases / $rnBases * 100.0 : 0) ),\n    ( sprintf \"%10d(%.4f%%)\",\n      $qnABases, ($qnBases ? $qnABases / $qnBases * 100.0 : 0) );\nHere, rnBases is the number of bases in the reference, and rnABases is the number of “aligned bases” from the reference participating in the alignment. $rnABases / $rnBases is the expected equation for calculating coverage.\nThe rnABases variable represents the sum of lengths of all aligned (reference) sequences, minus the number of gaps indicated in the corresponding output for the reference sequence as determined in the .rdiff file generated by show-diff (called by dnadiff.pl) from the many-to-many .delta file.\nThe documentation for show-diff states:\n\nThis program [show-diff] classifies alignment breakpoints for the quantification of macroscopic differences between two genomes. It takes a standard, unfiltered delta file as input, determines the best mapping between the two sequence sets, and reports on the breaks in that mapping.\n\nAlthough the documentation does not explicitly describe the algorithm, inspection of the source code suggests that show-diff considers a directed graph through all pairwise alignments between the genomes and aims to minimise the number of nodes (alignments) while maximising the coverage of the two genomes geing aligned. In this way it identifies a kind of golden path through all possible ways of reconstructing the alignment, and reports structural differences (gaps, inversions, breakpoints, etc.) between the two aligned genomes on the basis of this.\nThe way that dnadiff.pl calculates rnABases is to consider the .mcoords output from the show-coords tool, which summarises the content of the .mdelta file, with one row per alignment. The .mcoords file used has a form similar to that below (though we add the header, here):\n[S1]    [E1]    [S2]    [E2]    [LEN 1] [LEN 2] [% IDY] [LEN R] [LEN Q] [COV R] [COV Q] [TAGS]\n1   24024   63330   87353   24024   24024   99.98   87285   87353   27.52   27.50   MGV_MGV-GENOME-0357962  MGV_MGV-GENOME-0358017\n23884   24176   1   293 293 293 100.00  87285   87353   0.34    0.34    MGV_MGV-GENOME-0357962  MGV_MGV-GENOME-0358017\n24107   87285   176 63368   63179   63193   99.92   87285   87353   72.38   72.34   MGV_MGV-GENOME-0357962  MGV_MGV-GENOME-0358017\n\n\n\n\n\n\nNote\n\n\n\nThe .mcoords file provides values for sequence identity and sequence coverage. There is a single percentage identity value for each alignment, but a separate coverage measure for query and reference.\nThe identity figure appears to be calculated using the number of similarity errors. From the corresponding .delta file, the third alignment has 51 similarity errors, with 14 insertions. Taking LEN 1 and LEN 2 to be the number of aligned bases for reference and query, respectively, then 99.92% of 63179 is 51, and of 63193 is also 51. We can conclude that show-coords calculates alignment identity using the number of similarity errors.\nSimilarly, the query and reference coverage appear to be calculated as (aligned bases)/(sequence length); and the number of aligned bases in LEN 1 and LEN 2 is just the length of the aligned sequence.\n\n\nThe total alignment length is incremented as the variable $rnABases (previously initialised as zero) in the code below, as we iterate over the .mcoords file.\n#-- If new ID, add to sequence and base count\nif ( $refs{$A[11]} &gt; 0 ) {\n    $rnASeqs++;\n    $rnABases += $refs{$A[11]};\n    $refs{$A[11]} *= -1; # If ref has alignment, length will be -neg\n}\nThe variable $refs[$A[11]] represents the length of the FASTA sequence associated with the sequence ID in column 11 of the .mcoords table - i.e. the complete length of that sequence.\nThis is then modified later in the code by removing all of the GAP regions determined by show-diff: regions where the sequence does not align in the “golden path.” The .rdiff file has this form:\nMGV_MGV-GENOME-0357962  JMP 24025   23883   -141\nMGV_MGV-GENOME-0357962  GAP 24177   24106   -70 -118    48\nand is iterated over, storing column 4 in $gap for each line - this is used to modify the count of aligned bases:\n#-- Remove unaligned sequence from count\nif ( $A[1] ne \"DUP\" ) {\n  $rnABases -= $gap if ( $gap &gt; 0 );\n}\nSo, for the .rdiff file above, all elements in column 4 are negative, and no modification would occur.\n\n\n6.3.3 A second example\nIn this example, there is an 84bp unaligned region at the start of the reference, and about a 2kb overlap between the two aligned regions.\n\n\n\n\n\n\n.mdelta file\n\n\n\n\n\nhigh_align_cov/MGV-GENOME-0264574.fna high_align_cov/MGV-GENOME-0266457.fna\nNUCMER\n&gt;MGV_MGV-GENOME-0264574 MGV_MGV-GENOME-0266457 39253 39594\n85 37713 1 37636 215 215 0\n-3013\n-24624\n-1\n-1\n-1\n-1\n-1\n0\n17709 39253 17626 39176 7 7 0\n-9994\n-1\n-1\n-1\n-1\n-1\n0\n\n\n\n\n\n\n\n\n\n.mcoords file\n\n\n\n\n\n85  37713   1   37636   37629   37636   99.43   39253   39594   95.86   95.05   MGV_MGV-GENOME-0264574  MGV_MGV-GENOME-0266457\n17709   39253   17626   39176   21545   21551   99.97   39253   39594   54.89   54.43   MGV_MGV-GENOME-0264574  MGV_MGV-GENOME-0266457\n\n\n\n\n\n\n\n\n\n.rdiff file\n\n\n\n\n\nMGV_MGV-GENOME-0264574  BRK 1   84  84\nMGV_MGV-GENOME-0264574  GAP 37714   17708   -20005  -20011  6\n\n\n\n\n\n\n\n\n\n.qdiff file\n\n\n\n\n\nMGV_MGV-GENOME-0266457  GAP 37637   17625   -20011  -20005  -6\nMGV_MGV-GENOME-0266457  BRK 39177   39594   418\n\n\n\n\n\n\n\n\n\n.report file extract\n\n\n\n\n\n                               [REF]                [QRY]\n[Sequences]\nTotalSeqs                          1                    1\nAlignedSeqs               1(100.00%)           1(100.00%)\nUnalignedSeqs               0(0.00%)             0(0.00%)\n\n[Bases]\nTotalBases                     39253                39594\nAlignedBases           39169(99.79%)        39176(98.94%)\nUnalignedBases             84(0.21%)           418(1.06%)\n\n[Alignments]\n1-to-1                             2                    2\nTotalLength                    59174                59187\nAvgLength                   29587.00             29593.50\nAvgIdentity                    99.63                99.63\n\nM-to-M                             2                    2\nTotalLength                    59174                59187\nAvgLength                   29587.00             29593.50\nAvgIdentity                    99.63                99.63\n\n\n\nSo, to replicate the output of dnadiff.pl we can use the contents of MUMmer output as follows:\n\n.delta/.mdelta\n\nreference sequence length: 39253 ($rnBases)\nquery sequence length: 39594 ($qnBases)\nthe identifiers for every query/reference fragment that was aligned, giving\n\naligned reference bases (uncorrected): 39253\naligned query bases (uncorrected): 39594\n\n\n.rdiff\n\nnumber of reference sequence gaps: 84\nallowing correction:\n\naligned reference bases: 39253 - 84 = 39169 ($rnABases)\n\n\n.qdiff\n\nnumber of query sequence gaps: 418\nallowing correction:\n\naligned query bases: 39594 - 418 = 39176 ($rnABases)\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThis allows calculation of reference and query coverage as 39169 / 39253 = 0.9979 and 39176 / 39594 = 0.9894, respectively.\n\n\nWe can calculate the AvgIdentity values from the .mdelta file alone. For each alignment, we calculate the number of aligned bases from each sequence (using the file above), e.g.:\n\naligned reference bases: 37713 - 85 + 1 = 37629\naligned query bases: 37636 - 1 + 1 = 37636\nsimilarity errors: 215\npercentage identity = 1 - (2 * 215 / (37629 + 37636)) = 0.99429\n\nto get the percentage identity for a single alignment. To find an average across all alignments we might think we need to multiply through by the alignment length sum, as follows:\n\nalignment 1 identity weighted = (1 - (2 * 215 / (37629 + 37636))) * (37629 + 37636) = 74835.0\nalignment 2 identity weighted = (1 - (2 * 7 / (21545 + 21551))) * (21545 + 21551) = 43082.0\nsum of alignment lengths = 37629 + 37636 + 21545 + 21551 = 118361\naverage identity = (74835 + 43082) / 118361 = 0.99625\n\nBut a quicker way to calculate this would be to skip the intermediate calculation of identity, as follows:\n\nalignment 1 identity weighted = (37629 + 37636) - (2 * 215) = 74835\nalignment 2 identity weighted = (21545 + 21551) - (2 * 7) = 43082\naverage identity = (74835 + 43082) / (37629 + 37636 + 21545 + 21551) = 0.99625\n\nAnd we would only need to keep a running tally of the sum of weighted identical bases, and the sum of aligned bases from each fragment at each step. This could be quite fast.",
    "crumbs": [
      "ANIm",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>`.delta` files</span>"
    ]
  },
  {
    "objectID": "snakemake.html",
    "href": "snakemake.html",
    "title": "7  snakemake usage",
    "section": "",
    "text": "7.1 Advantages of snakemake",
    "crumbs": [
      "ANIm",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`snakemake` usage</span>"
    ]
  },
  {
    "objectID": "snakemake.html#advantages-of-snakemake",
    "href": "snakemake.html#advantages-of-snakemake",
    "title": "7  snakemake usage",
    "section": "",
    "text": "7.1.1 Snakemake is well-maintained, and widely-used\n\nsnakemake documentation\n\n\n\n7.1.2 Snakemake distributes jobs\nA major hassle with the older versions of pyani was keeping on top of cluster scheduler changes. snakemake has plugins for cluster and cloud operation, so it should be possible for us to ride on top of that and maintain a single interface to snakemake to handle our job dependencies and distribution.\n\nCluster/cloud execution documentation\nSLURM executor plugin documentation",
    "crumbs": [
      "ANIm",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`snakemake` usage</span>"
    ]
  },
  {
    "objectID": "snakemake.html#using-the-snakemake-cli",
    "href": "snakemake.html#using-the-snakemake-cli",
    "title": "7  snakemake usage",
    "section": "7.2 Using the snakemake CLI",
    "text": "7.2 Using the snakemake CLI\nWith the CLI we call snakemake and pass it the path to the snakefile (which defines and configures the workflow), the number of cores, and any other arguments. The snakefile An example is given below.\n# Example snakemake file performing pairwise comparisons\nfrom itertools import permutations\n\n# Pick up genome filestems\n(GENOMES,) = glob_wildcards(\"data/{genome}.fna\")\nCMPS = list(permutations(GENOMES, 2))  # all pairwise comparisons fwd and reverse\n\n# Rule `all` defines all A vs B comparisons, the `nucmer` rule runs a\n# single pairwise comparison at a time\n# The `zip` argument to `expand()` prevents this function generating the\n# product of every member of each list. Instead we have extracted each\n# participant in all pairwise comparisons into separate lists\nrule all:\n    input:\n        expand(\n            \"results/{genomeA}_vs_{genomeB}.delta\",\n            zip,\n            genomeA=[_[0] for _ in CMPS],\n            genomeB=[_[1] for _ in CMPS],\n            # outdir=OUTDIR,\n        ),\n\n\n# The nucmer rule runs nucmer in the forward direction only\nrule nucmer:\n    output:\n        \"{outdir}/{genomeA}_vs_{genomeB}.delta\",\n    run:\n        shell(\n            \"nucmer data/{wildcards.genomeA}.fna data/{wildcards.genomeB}.fna \"\n            \"-p {wildcards.outdir}/{wildcards.genomeA}_vs_{wildcards.genomeB} \"\n            \"--maxmatch\"\n        )\nThis example will take all the .fna files in the data subdirectory and generate all the pairwise combinations (forward and reverse) for comparison. Running the snakefile with snakemake --snakefile example.sml --cores all runs these pairwise comparisons and puts the output in the results subdirectory.",
    "crumbs": [
      "ANIm",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`snakemake` usage</span>"
    ]
  },
  {
    "objectID": "snakemake.html#programmatic-workflows-with-snakemake",
    "href": "snakemake.html#programmatic-workflows-with-snakemake",
    "title": "7  snakemake usage",
    "section": "7.3 Programmatic workflows with snakemake",
    "text": "7.3 Programmatic workflows with snakemake\nAs snakemake is written in Python and exposes its internals with an API, we can control workflows programmatically. In the example.py file, we use the API to specify target output files for the example.smk workflow, giving us control over which comparisons are run.\n\n\n\n\n\n\nImportant\n\n\n\nThis ability will be important for us, as we will be using a database backend to avoid the need to rerun comparisons for which we already have data. So our actual workflow will be something like:\n\nparse input data directory\nfilter the input data against the databse to identify only comparisons that have not been run before\npass the expected output files to snakemake so that snakemake handles the job distribution\n\n\n\n# Example file calling snakemake scheduler from Python\n\nfrom pathlib import Path\nfrom snakemake.api import SnakemakeApi, _get_executor_plugin_registry\nfrom snakemake.settings import ConfigSettings, DAGSettings, ResourceSettings\n\n# In a real situation, we can choose a snakefile to suit the analysis\nsnakefile = Path(\"example.smk\")\n\n# Define arguments to pass to the snakefile\n# config_args = {\"outdir\": \"script_results\"}\n\n# Define a subset of target files to generate\ntarget_files = [\"script_results/genome_2_vs_genome_3.delta\",\n                \"script_results/genome_4_vs_genome_3.delta\"]\n\n# Use the defined workflow from the Python API\nwith SnakemakeApi() as snakemake_api:\n    workflow_api = snakemake_api.workflow(snakefile=snakefile,\n                                          resource_settings=ResourceSettings(cores=8),\n                                          config_settings=ConfigSettings(\n                                              config=config_args,\n                                              )\n                                          )\n    dag_api = workflow_api.dag(\n        dag_settings = DAGSettings(\n            targets=target_files,  \n        )\n    )\n    dag_api.execute_workflow()\n\n\n\n\n\n\nWarning\n\n\n\nThe snakemake API is not documented in a detailed way. The best resource is to start at the actual CLI code for snakemake, linked below.\n\nAPI example - CLI code for snakemake",
    "crumbs": [
      "ANIm",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>`snakemake` usage</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "8  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "All Contributors",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#all-contributors",
    "href": "resources.html#all-contributors",
    "title": "Resources",
    "section": "",
    "text": "All Contributors documentation: https://allcontributors.org/docs/en/overview",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#click",
    "href": "resources.html#click",
    "title": "Resources",
    "section": "click",
    "text": "click\n\nclick documentation: https://click.palletsprojects.com/en/8.1.x/",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#doi-to-bibtex-conversion",
    "href": "resources.html#doi-to-bibtex-conversion",
    "title": "Resources",
    "section": "DOI to BibTeX conversion",
    "text": "DOI to BibTeX conversion\n\nDOI to BibTeX converter: https://www.bibtex.com/c/doi-to-bibtex-converter/",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#github",
    "href": "resources.html#github",
    "title": "Resources",
    "section": "GitHub",
    "text": "GitHub\n\nCreating a GitHub issue: https://docs.github.com/en/issues/tracking-your-work-with-issues/creating-an-issue\nCreating a pull request: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request\nGitHub Actions documentation: https://docs.github.com/en/actions\nRepository forks: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#jspecies",
    "href": "resources.html#jspecies",
    "title": "Resources",
    "section": "JSpecies",
    "text": "JSpecies\n\nJSpeciesWS online service: https://jspecies.ribohost.com/jspeciesws/#home",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#mummer",
    "href": "resources.html#mummer",
    "title": "Resources",
    "section": "MUMmer",
    "text": "MUMmer\n\nMUMmer3 manual: https://mummer.sourceforge.net/manual/\n\n.delta output format: https://mummer.sourceforge.net/manual/#nucmeroutput\nshow-coords with description of output format: https://mummer.sourceforge.net/manual/#coords\n\n\n\nPublications\n\nKurtz et al. (2004)",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#quarto",
    "href": "resources.html#quarto",
    "title": "Resources",
    "section": "Quarto",
    "text": "Quarto\n\nThe Quarto project: https://quarto.org/\nThe Quarto guide: https://quarto.org/docs/guide/\nPublishing Quarto on GitHub pages: https://quarto.org/docs/publishing/github-pages.html",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#rrstudio",
    "href": "resources.html#rrstudio",
    "title": "Resources",
    "section": "R/RStudio",
    "text": "R/RStudio\n\nRStudio Desktop: https://posit.co/download/rstudio-desktop/",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#rich",
    "href": "resources.html#rich",
    "title": "Resources",
    "section": "rich",
    "text": "rich\n\nrich documentation: https://rich.readthedocs.io/en/stable/introduction.html",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#sqlite3",
    "href": "resources.html#sqlite3",
    "title": "Resources",
    "section": "SQLite3",
    "text": "SQLite3\n\naiosqlite: library for asynchronous access to sqlite3\nPython sqlite3 module: https://docs.python.org/3/library/sqlite3.html\n\nThreadsafety in the sqlite3 module: https://docs.python.org/3/library/sqlite3.html#sqlite3.threadsafety\n\nThreadsafe modes with sqlite3: https://www.sqlite.org/threadsafe.html",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "resources.html#visual-studio-code",
    "href": "resources.html#visual-studio-code",
    "title": "Resources",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\n\nVisual Studio Code: https://code.visualstudio.com/\n\n\n\n\n\nKurtz, Stefan, Adam Phillippy, Arthur L Delcher, Michael Smoot, Martin Shumway, Corina Antonescu, and Steven L Salzberg. 2004. “Versatile and Open Software for Comparing Large Genomes.” Genome Biol. 5 (2): R12.",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Kurtz, Stefan, Adam Phillippy, Arthur L Delcher, Michael Smoot, Martin\nShumway, Corina Antonescu, and Steven L Salzberg. 2004. “Versatile\nand Open Software for Comparing Large Genomes.” Genome\nBiol. 5 (2): R12.\n\n\nRichter, Michael, and Ramon Rosselló-Móra. 2009. “Shifting the\nGenomic Gold Standard for the Prokaryotic Species Definition.”\nProc. Natl. Acad. Sci. U. S. A. 106 (45): 19126–31.",
    "crumbs": [
      "References"
    ]
  }
]